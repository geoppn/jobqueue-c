============================================================================================================================================================================
Γεώργιος Παπαϊωάννου - 1115202100222

MAKE INSTRUCTIONS:

make all -  Προετοιμάζει όλα τα απαραίτητα προγράμματα για το project.

make clean -  Διαγράφει τα εκτελέσιμα αρχεία, μαζί με το .txt και τους αγωγούς με το όνομα.

make jobExecutorServer/jobCommander - Κανει compile το ανάλογο πρόγραμμα
============================================================================================================================================================================

Στο πλαίσιο αυτής της εργασίας, έχω γράψει ένα ζεύγος αρχείων .c και .h για την υλοποίηση της απαιτούμενης δομής ουράς μαζί με ορισμένες λεπτομέρειες,
όπως το κύριο struct για τις οντότητες της εργασίας μου. Θα αναλύσω κάθε αρχείο και θα εξηγήσω τις λειτουργίες του, τη λογική του και τις αλλαγές που ενδεχομένως έχω κάνει.

Ας ξεκινήσουμε με το αρχείο jobQueue.h:

JobStatus: Αυτό είναι ένα enumeration που αντιπροσωπεύει την κατάσταση ενός job. Μπορεί να είναι είτε QUEUED είτε RUNNING.
Job: Αυτό είναι ένα struct που αντιπροσωπεύει ένα job. Έχει τα εξής πεδία:
    id: Ένα string που αντιπροσωπεύει το ID του job.
    pid: Ένα process ID.
    command: Ένα string που αντιπροσωπεύει την εντολή του job.
    queuePosition: Ένας ακέραιος που αντιπροσωπεύει τη θέση του job στην ουρά.

Συνεχίζοντας με το αρχείο jobQueue.c, θα βρούμε τις εξής συναρτήσεις:

    * getQueueLength: Επιστρέφει το τρέχον μήκος της ουράς, το χρησιμοποιούμε ως αντικαταστάτη μιας global μεταβλητής για να καλύψουμε μια ακραία περίπτωση. 
Χρειάζεται επίσης για την υλοποίηση των άλλων συναρτήσεων σε αυτό το αρχείο.
    * addJob: Μετατρέπει μια εντολή στη δομή Job μου, προσδίδοντάς της ένα job_id, ορίζοντας την κατάστασή της, καθώς και άλλες απαραίτητες πληροφορίες σχετικά με αυτήν.
Την προσθέτει επίσης στην ουρά ως queued.
    * getNextJob: Επιστρέφει NULL εάν δεν υπάρχουν επόμενες εργασίες στην ουρά, διαφορετικά επιστρέφει την επόμενη εργασία στην ουρά χωρίς να την αφαιρέσει από αυτήν.
    * findJobById: Επαναλαμβάνει την ουρά και επιστρέφει την εργασία που ταιριάζει με το ID που δόθηκε.
    * removeJob: Αφαιρεί μια συγκεκριμένη εργασία από την ουρά (όταν απαιτείται από την εντολή stop ή όταν τελειώσει η εκτέλεσή της), ενημερώνει επίσης τη θέση της ουράς των υπόλοιπων εργασιών στην ουρά.
    * getJobDetailsWithStatus: Συγκεντρώνει και επιστρέφει μια συμβολοσειρά με όλες τις εργασίες στην ουρά που ταιριάζουν με την κατάσταση που δόθηκε. Χρησιμοποιείται για ευκολία κατά την υλοποίηση της εντολής Poll.

Επομένος, έχουμε το JobCommander.c:
Πρώτον, δημιουργεί δύο named σωλήνες μίας κατεύθυνσης που θα χρησιμοποιηθούν από τις περιπτώσεις jobCommander και τον διακομιστή για να επικοινωνούν και προς τις δύο κατευθύνσεις.
Στη συνέχεια, ελέγχει αν το αρχείο .txt του Server υπάρχει, αν δεν υπ άρχει, χρησιμοποιεί την execl σε ένα πρόσφατα forked παιδί για να καλέσει το Server, το οποίος στη συνέχεια δημιουργεί το αρχείο και παραμένει σε λειτουργία.
Επίσης, κάνουμε sleep τον parent για μισό δευτερόλεπτο ώστε να δώσουμε χρόνο για τη δημιουργία του αρχείου. Ο Server γράφει το PID του στο αρχείο txt, το οποίο στη συνέχεια διαβάζουμε και αποθηκεύουμε τοπικά.
Στη συνέχεια προετοιμάζουμε την εντολή που θα σταλεί στον Server χρησιμοποιώντας τα arg που παρέχωνται απτον χρήστη. Στη συνέχεια στέλνουμε ένα σήμα SIGUSR1 για να δείξουμε ότι θα γράψουμε στον Server. 
Ο χειριστής του σήματος του Server θα αναλάβει την εντολή ανάλογα. Ανοίγουμε τον απαραίτητο σωλήνα και γράφουμε την εντολή. Μετά από αυτό το σημείο, ο υπόλοιπος κώδικας του Commander είναι για τη λήψη των μηνυμάτων που στέλνονται από τον Server ως απάντηση-
κάτι που γίνεται ελέγχοντας ποια εντολή στάλθηκε και ενεργώντας ανάλογα. Για τις εντολές exit, poll και stop οι οποίες απαιτούν την εκτύπωση μιας απάντησης από τον Commander, ανοίγουμε τον σωλήνα ανάγνωσης, διαβάζουμε το μήνυμα ανάλογα και στη συνέχεια κλείνουμε/αποσυνδέουμε τους σωλήνες όπου χρειάζεται.
Τέλος, κλείνουμε το σωλήνα και η διάρκεια ζωής του Commander φτάνει στο τέλος της.

Τέλος, έχουμε τον JobExecutorServer, ο οποίος είναι το κεντρικό μέρος του έργου μας.

Ξεκινάμε με τον ορισμό κάποιων σημαντικών global μεταβλητών, καθώς ο Server ειναι ενεργός μέχρι να δώσουμε την εντολή exit, επομένως οι τιμές που χρειαζόμαστε διατηρούνται. 
Δηλώνουμε τις μεταβλητές concurrency και running_jobs για να παρακολουθούμε την τιμή του concurrency και το πλήθος των εργασιών που εκτελούνται αυτή τη στιγμή.
Στη συνέχεια, έχουμε μια απλή υλοποίηση μιας συνδεδεμένης λίστας με συναρτήσεις add/remove- αυτό είναι απαραίτητο για το χειρισμό της αφαίρεσης των εργασιών από το queue μετά το τέλος της εκτέλεσής τους.
Στην κύρια συνάρτησή μας, αρχικοποιούμε τους δύο singal handlers στους οποίους θα αναφερθούμε σύντομα, δημιουργούμε το αρχείο .txt αν χρειάζεται και γράφουμε το PID του Server σε αυτό. 
Τέλος, χρησιμοποιούμε την pause() ως έναν infinite βρόχο για να μείνει ο Server σε αδράνεια μέχρι να λάβει ένα signal.

Τώρα, η διαδικασία λειτουργεί με δύο σήματα, το SIGUSR1 το οποίο όπως αναφέρθηκε προηγουμένως παρέχεται από το JobCommander ως ένδειξη ότι θα γράψει κάτι στο pipe και το χρησιμοποιείται για να χειριστεί τις εντολές που παρέχονται. 
Έχουμε επίσης το SIGCHLD το οποίο ως επί το πλείστον αφαιρεί εργασίες από την ουρά και τις αντικαθιστά με νέες εργασίες με βάση τo concurrency.

Αναλυτικά:
Όταν λαμβάνουμε ένα SIGUSR1, χρησιμοποιούμε ένα buffer (το οποίο μηδενίζουμε σε κάθε περίπτωση για να αποφύγουμε προβλήματα) για να κρατήσουμε την εντολή και στη συνέχεια να την αναλύσουμε και να την τροποποιήσουμε ανάλογα για να την εκτελέσουμε. 
Αφού ανοίξουμε τον σωλήνα και διαβάσουμε την εντολή, κλείνουμε τον σωλήνα για να αποφύγουμε θέματα με το concurrency και χρησιμοποιούμε το strtok για να φτάσουμε στο πρώτο όρισμα που μας ενδιαφέρει, τον τύπο της εντολής. 
Χρησιμοποιούμε μια σειρά από if/elseif για να χειριστούμε κάθε τύπο εντολής. Έχουμε:

    * setConcurrency: Σε αυτή την περίπτωση χρησιμοποιούμε την strtok για να λάβουμε το ποσό που παρέχεται και να αλλάξουμε την global μεταβλητή μας αναλόγως. 
Στη συνέχεια, χρησιμοποιούμε την ίδια λογική που χρησιμοποιούμε στο SIGCHLD για να αντικαταστήσουμε τις τελειωμένες εργασίες για να καλύψουμε τυχόν κενά στις εκτελούμενες εργασίες με βάση τη νέα τιμή του concurrency.
Η λογική θα εξηγηθεί στη συνέχεια.
    * stop: Σε αυτή την περίπτωση, πρέπει να στείλουμε ένα μήνυμα πίσω στο JobCommander, επομένως προετοιμάζουμε ένα buffer για αυτό. 
Παίρνουμε την τιμή χρησιμοποιώντας την strtok και χρησιμοποιούμε τη συνάρτηση findJobById της ουράς μας για να βρούμε την εν λόγω εργασία. Εάν βρεθεί η εργασία, ελέγχουμε την κατάστασή της. 
Εάν εκτελείται, στέλνουμε ένα SIGTERM για να την τερματίσουμε και τροποποιούμε το μήνυμά μας αναλόγως- αυτό παράγει ένα SIGCHLD το οποίο φροντίζει για κάθε άλλη απαίτηση. 
Αν είναι σε ουρά, την αφαιρούμε τόσο από την ουρά όσο και από τη λίστα, προετοιμάζοντας το μήνυμα αναλόγως. Έχουμε μια περίπτωση για την περίπτωση που η εργασία δεν βρίσκεται και τότε χειριζόμαστε τους σωλήνες και στέλνουμε το μήνυμα πίσω στον Commander για να διαβαστεί και να εκτυπωθεί.
    * exit: Σε αυτή την περίπτωση, διαγράφουμε το αρχείο .txt, διακόπτοντας την επικοινωνία από τον Commander, ανοίγουμε στη συνέχεια το σωλήνα για write και δηλώνουμε το string μας. Γράφουμε το μήνυμα στον σωλήνα και κάνουμε sleep για μισό δευτερόλεπτο πριν κλείσουμε τον σωλήνα write για να αποφύγουμε περιττά προβλήματα.
    * issueJob: Αφού χειριστούμε την εντολή που λάβαμε, για την περίπτωση αυτή εκτυπώνουμε την τριπλέτα που ζητήθηκε στην εκφώνηση και στη συνέχεια ελέγχουμε αν υπάρχουν λιγότερες καταχωρήσεις στην ουρά από την τιμή του concurrency. Αν και χειριζόμαστε κυρίως την εκτέλεση των εργασιών στον χειριστή SIGCHLD, 
    αυτό το μοτίβο πρέπει να ξεκινήσει από κάπου, καθώς τα σήματα SIGCHLD αποστέλλονται όταν μια διεργασία τερματίζεται. Επομένως, χρησιμοποιούμε το execvp με το όρισμα bin/sh για να εκτελέσουμε την εντολή μας σε ένα forked παιδί. Στο γονέα, προσθέτουμε σημαντικές πληροφορίες όπως το PID του παιδιού και αλλάζουμε την κατάστασή της σε running, 
    προσθέτουμε επίσης την εργασία στη λίστα running jobs και αυξάνουμε την global μεταβλητή μας. Μόλις ολοκληρωθεί μια εργασία, η αφαίρεση και η αντικατάστασή της γίνεται από τον χειριστή SIGCHLD.
    * poll [queued/running]: Αναλύουμε τη ζητούμενη κατάσταση, εκτυπώνοντας ένα αντίστοιχο μήνυμα αν δεν είναι "running" ή "queued". Προετοιμάζουμε το buffer και το pipe μας για να απαντήσουμε στον Commander και παίρνουμε δύο περιπτώσεις με βάση την κατάσταση που ζητείται. 
    Όπως αναφέρθηκε προηγουμένως, έχουμε μια συνάρτηση του queue που συντάσσει το απαιτούμενο μήνυμα για την poll, οπότε εκτυπώνουμε ένα μήνυμα, τερματίζουμε τη συμβολοσειρά μας με ένα /0 για να αποφύγουμε προβλήματα, χειριζόμαστε τη μνήμη και στη συνέχεια γράφουμε το μήνυμα πίσω στο pipe.

Τέλος, έχουμε τον χειριστή SIGCHLD, 
ο οποίος χρησιμοποιεί έναν βρόχο με waitpid, χρησιμοποιώντας το όρισμα WNOHANG, το οποίο κάνει τον γονέα να μην μπλοκάρει, επομένως δεν περιμένει την ολοκλήρωση των παιδιών του. 
Αυτό μας επιτρέπει να μειώνουμε την global μεταβλητή running_jobs όταν ένα παιδί έχει τελειώσει. Τώρα, αναφερόμαστε στην global λίστα GjobID μας για να εντοπίσουμε την εργασία που μόλις τελείωσε και να την αφαιρέσουμε από την ουρά καθώς έχει τερματιστεί- 
την αφαιρούμε επίσης από τη λίστα. Τέλος, το αντικαθιστούμε χρησιμοποιώντας ένα βρόχο για να γεμίσουμε το queue με βάση την διαφορά μεταξύ του τρέχοντος αριθμού εργασιών που εκτελούνται και του μέγιστου επιτρεπόμενου αριθμού εργασιών (concurrency). 
Εντός του βρόχου, ενημερώνουμε την κατάσταση της εργασίας που θα εκτελεστεί, διαχωρίζουμε ένα παιδί και εκτελούμε την επόμενη εργασία στην ουρά (εάν υπάρχει), την οποία λαμβάνουμε χρησιμοποιώντας το getNextJob(). 
Όπως και στο issueJob, αποθηκεύουμε το PID για μελλοντική χρήση και διασφαλίζουμε ότι το running_jobs είναι ενημερωμένο!

============================================================================================================================================================================

Με την υλοποίησή μου, αφού εφτιαξα όλα τα μικρο-προβλήματα του κώδικα, ολες οι περιπτώσεις δοκιμής που παρέχονται εκτελούνται όπως αναμενόνται, με εξαίρεση το test 3, το οποίο παράγει segfault, αλλά όταν οι εντολές εκτελούνται υπό valgrind, λειτουργεί σωστά, 
επομένως δεν μπόρεσα να προσδιορίσω την πιθανή διαρροή μνήμης για να διορθώσω την κατάσταση.

Οι άλλες πτυχές της εργασίας λειτουργούν όπως προβλέπεται και έχω εφαρμόσει ελέγχους σφαλμάτων όπου χρειάζεται και χειρίζομαι ακραίες περιπτώσεις, όπως μη αριθμητικές/αρνητικές τιμές για την setConcurrency.

Τα bash scripts λειτουργούν, με την multijob να περνα όλες τις παρεχόμενες δοκιμαστικές περιπτώσεις.
Για την allJobsStop, χρησιμοποιώ το ίδιο το πρόγραμμα (jobCommander) μαζι με bash scripting για να εξαγάγω τα job_id από το τυπωμένο μήνυμα της poll running/queued σε ενα πίνακα και τα αφαιρω χρησιμοποιώντας την εντολή stop που υλοποίησα σε ενα απλο βρόχο.

Για τυχόν ερωτήσης, sdi2100222@di.uoa.gr